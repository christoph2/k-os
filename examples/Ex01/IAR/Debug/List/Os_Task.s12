//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR HCS12 C/C++ Compiler V3.11A/W32                 17/Mar/2010  10:33:32 /
// Copyright 1997-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  C:\projekte\csProjects\k-os\src\Os_Task.c              /
//    Command line =  C:\projekte\csProjects\k-os\src\Os_Task.c              /
//                    --preprocess=l C:\projekte\csProjects\k-os\examples\Ex /
//                    01\IAR\Debug\List\ -lC C:\projekte\csProjects\k-os\exa /
//                    mples\Ex01\IAR\Debug\List\ -lB                         /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\ --code_model=normal --double=32 -o                 /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Ob /
//                    j\ --require_prototypes -e -z2 --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa                 /
//                    --no_cross_call --debug "-D_DLIB_CONFIG_FILE=C:\Progra /
//                    mme\IAR Systems\Embedded Workbench Evaluation          /
//                    4.0\HCS12\LIB\DLIB\dlhcs12nfn.h" --segment             /
//                    __data8=DATA8 --segment __data16=DATA16 --segment      /
//                    __banked=BANKED_CODE --segment __non_banked=CODE       /
//                    --segment __intvec=INTVEC --segment __difunct=DIFUNCT  /
//                    --segment __cstack=CSTACK --segment __inittab=INITTAB  /
//                    -I C:\projekte\csProjects\k-os\inc\ -I                 /
//                    C:\projekte\csProjects\common\inc\ -I                  /
//                    C:\projekte\csProjects\common\ -I                      /
//                    C:\projekte\csProjects\common\InstallISR\ -I           /
//                    C:\projekte\csProjects\k-os\examples\Ex01\ -I          /
//                    C:\projekte\csProjects\common\drivers\include\cpu12\   /
//                    -I "C:\Programme\IAR Systems\Embedded Workbench        /
//                    Evaluation 4.0\HCS12\INC\" -I "C:\Programme\IAR        /
//                    Systems\Embedded Workbench Evaluation                  /
//                    4.0\HCS12\INC\DLIB\"                                   /
//    List file    =  C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\Os_Task.s12                                         /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Os_Task

        RSEG CSTACK:DATA:REORDER:NOROOT(0)

        PUBLIC ActivateTask
        PUBLIC ChainTask
        PUBLIC GetTaskID
        PUBLIC GetTaskState
        PUBLIC OsTask_Activate
        PUBLIC OsTask_InitTasks
        PUBLIC OsTask_Ready
        PUBLIC OsTask_Suspend
        PUBLIC OsTask_Wait
        PUBLIC Schedule
        PUBLIC TerminateTask

        EXTERN OS_TCB
        EXTERN Os_ServiceContext
        EXTERN OsFlags
        EXTERN OsCallevel
        EXTERN OS_TaskConf
        EXTERN OsCurrentTCB
        EXTERN OsCurrentTID
        EXTERN GetActiveApplicationMode
        EXTERN OSSaveServiceContext
        EXTERN OsErrorCallErrorHook
        EXTERN OsExec_StartHighestReadyTask
        EXTERN OsMLQ_AddTaskLast
        EXTERN OsMLQ_RemoveTask
        EXTERN OsPortTaskStackInit
        EXTERN OsRes_ReleaseInternalResource
        EXTERN ResumeOSInterrupts
        EXTERN SuspendOSInterrupts
        EXTERN Utl_BitGet

// C:\projekte\csProjects\k-os\src\Os_Task.c
//    1 /*
//    2  * k_os (Konnex Operating-System based on the OSEK/VDX-Standard).
//    3  *
//    4  * (C) 2007-2009 by Christoph Schueler <chris@konnex-tools.de>
//    5  *
//    6  * All Rights Reserved
//    7  *
//    8  * This program is free software; you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation; either version 2 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License along
//   19  * with this program; if not, write to the Free Software Foundation, Inc.,
//   20  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//   21  *
//   22  */
//   23 
//   24 #include "Osek.h"
//   25 
//   26 
//   27 static void OsTask_Init(TaskType TaskID,boolean Schedule);
//   28 
//   29 

        RSEG CODE:CODE:NOROOT(0)
//   30 void OsTask_Ready(TaskType TaskID)       /* OsTask_ReadyTask  */
OsTask_Ready:
//   31 {
        PSHA
        STAB    0x0,SP
//   32 #if defined(OS_USE_RESOURCES)
//   33     OsMLQ_AddTaskLast(TaskID,OS_TCB[TaskID].CurrentPriority);
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        LDAA    OS_TCB + 6,Y
        LDAB    0x0,SP
        JSR     OsMLQ_AddTaskLast
//   34 #else
//   35     OsMLQ_AddTaskLast(TaskID,OS_TaskConf[TaskID].Priority);
//   36 #endif
//   37     OS_TCB[TaskID].State=READY;
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        LDAB    #0x1
        STAB    OS_TCB + 2,Y
//   38 }
        PULA
        RTS
//   39 
//   40 

        RSEG CODE:CODE:NOROOT(0)
//   41 void OsTask_Suspend(TaskType TaskID) /* OsTask_SuspendTask */
OsTask_Suspend:
//   42 {
        PSHA
        STAB    0x0,SP
//   43     OsMLQ_RemoveTask(TaskID);
        LDAB    0x0,SP
        JSR     OsMLQ_RemoveTask
//   44     OS_TCB[TaskID].State=SUSPENDED;
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        CLR     OS_TCB + 2,Y
//   45 }
        PULA
        RTS
//   46 
//   47 

        RSEG CODE:CODE:NOROOT(0)
//   48 void OsTask_Wait(TaskType TaskID)        /* OsTask_WaitTask  */
OsTask_Wait:
//   49 {
        PSHA
        STAB    0x0,SP
//   50     OsMLQ_RemoveTask(TaskID);
        LDAB    0x0,SP
        JSR     OsMLQ_RemoveTask
//   51     OS_TCB[TaskID].State=WAITING;
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        LDAB    #0x3
        STAB    OS_TCB + 2,Y
//   52 }
        PULA
        RTS
//   53 
//   54 

        RSEG CODE:CODE:NOROOT(0)
//   55 StatusType OsTask_Activate(TaskType TaskID)
OsTask_Activate:
//   56 {
        PSHA
        STAB    0x0,SP
//   57     SAVE_SERVICE_CONTEXT(OSServiceId_ActivateTask,TaskID,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x2
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//   58 
//   59     ASSERT_VALID_TASKID(TaskID);
        TST     0x3,SP
        LEAS    0x3,SP
        BEQ     ??OsTask_Activate_3
        LDAB    0x0,SP
        CMPB    #0x4
        BCS     ??OsTask_Activate_4
??OsTask_Activate_3:
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??OsTask_Activate_5
//   60     ASSERT_INTERRUPTS_ENABLED_AT_TASK_LEVEL();
??OsTask_Activate_4:
        TFR     CCR,B
        BITB    #0x10
        BEQ     ??OsTask_Activate_6
        BRCLR   OsFlags,#0x2,??OsTask_Activate_0
        BRA     ??OsTask_Activate_6
??OsTask_Activate_0:
        LDAB    #0x13
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x13
        BRA     ??OsTask_Activate_5
//   61     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2);
??OsTask_Activate_6:
        BRCLR   OsCallevel + 1,#0x3,??OsTask_Activate_1
        BRA     ??OsTask_Activate_7
??OsTask_Activate_1:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??OsTask_Activate_5
//   62     WARN_IF_TO_MANY_ACTIVATIONS(TaskID);
??OsTask_Activate_7:
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        TST     OS_TCB + 2,Y
        BEQ     ??OsTask_Activate_8
        LDAB    #0x4
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x4
        BRA     ??OsTask_Activate_5
//   63 
//   64     DISABLE_ALL_OS_INTERRUPTS();
??OsTask_Activate_8:
        JSR     SuspendOSInterrupts
//   65     OS_TASK_INCR_ACTIVATIONS(TaskID);
//   66 
//   67 #if defined(OS_BCC2) || defined(OS_ECC2)
//   68     if (OS_IS_TASK_SUSPENDED(TaskID)) {
//   69 #endif
//   70         OS_TASK_CLEAR_ALL_EVENTS(TaskID);
        LDAB    0x0,SP
        LDAA    #0x9
        MUL
        TFR     D,Y
        BRCLR   OS_TaskConf + 6,Y,#0x2,??OsTask_Activate_2
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        CLR     OS_TCB + 3,Y
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        CLR     OS_TCB + 4,Y
//   71         OsTask_Ready(TaskID);
??OsTask_Activate_2:
        LDAB    0x0,SP
        JSR     OsTask_Ready
//   72         OsTask_Init(TaskID,FALSE);
        LDAA    #0x0
        LDAB    0x0,SP
        JSR     OsTask_Init
//   73 #if     defined(OS_BCC2) || defined(OS_ECC2)
//   74     }
//   75 #endif
//   76     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//   77 
//   78     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//   79     return E_OK;
        LDAB    #0x0
??OsTask_Activate_5:
        PULA
        RTS
//   80 }
//   81 
//   82 

        RSEG CODE:CODE:NOROOT(0)
//   83 StatusType ActivateTask(TaskType TaskID)
ActivateTask:
//   84 {
        PSHD
        STAB    0x1,SP
//   85 /*
//   86 **
//   87 **      'E_OS_LIMIT': maximum Number of Activations reached; 'ActivateTask' on
//   88 **              ready/running/waiting Extended Task (gilt auch für 'ChainTask()').
//   89 **
//   90 **      'E_OS_ID': invalid TaskID. (EXTENDED_STATUS)
//   91 **
//   92 */
//   93     StatusType Status=OsTask_Activate(TaskID);
        LDAB    0x1,SP
        JSR     OsTask_Activate
        STAB    0x0,SP
//   94 
//   95     if (Status!=E_OK) {
        TST     0x0,SP
        BEQ     ??ActivateTask_1
//   96         return Status;
        LDAB    0x0,SP
        BRA     ??ActivateTask_2
//   97     } else {
//   98         OS_COND_SCHEDULE_FROM_TASK_LEVEL();
??ActivateTask_1:
        BRCLR   OsFlags,#0x2,??ActivateTask_0
        BRA     ??ActivateTask_3
??ActivateTask_0:
        LDY     OsCurrentTCB
        LDAB    0x6,Y
        INCB
        BEQ     ??ActivateTask_3
        SWI
//   99         return E_OK;
??ActivateTask_3:
        LDAB    #0x0
??ActivateTask_2:
        PULY
        RTS
//  100     }
//  101 }
//  102 
//  103 

        RSEG CODE:CODE:NOROOT(0)
//  104 StatusType TerminateTask(void)
TerminateTask:
//  105 {
//  106 /*
//  107 **      Standard-Status: no return to Calllevel.
//  108 **      Extended-Status:
//  109 **              – E_OS_RESOURCE – the task still occupies resources.
//  110 **              – E_OS_CALLEVEL – a call at the interrupt level.
//  111 **
//  112 */
//  113     SAVE_SERVICE_CONTEXT(OSServiceId_TerminateTask,NULL,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x4
        PSHB
        LDD     #0x0
        LDY     #0x0
        JSR     OSSaveServiceContext
//  114     ASSERT_VALID_CALLEVEL(OS_CL_TASK);
        LEAS    0x3,SP
        BRCLR   OsCallevel + 1,#0x1,??TerminateTask_0
        BRA     ??TerminateTask_3
??TerminateTask_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        RTS
//  115     ASSERT_INTERRUPTS_ENABLED_AT_TASK_LEVEL();
??TerminateTask_3:
        TFR     CCR,B
        BITB    #0x10
        BEQ     ??TerminateTask_4
        BRCLR   OsFlags,#0x2,??TerminateTask_1
        BRA     ??TerminateTask_4
??TerminateTask_1:
        LDAB    #0x13
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x13
        RTS
//  116     ASSERT_CURR_TASK_OCCUPIES_NO_RESOURCES();
??TerminateTask_4:
        LDY     OsCurrentTCB
        TST     0x5,Y
        BNE     ??TerminateTask_5
        BRCLR   OsFlags,#0x1,??TerminateTask_2
??TerminateTask_5:
        LDAB    #0x6
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x6
        RTS
//  117 
//  118     DISABLE_ALL_OS_INTERRUPTS();
??TerminateTask_2:
        JSR     SuspendOSInterrupts
//  119     OS_TASK_DECR_ACTIVATIONS(OsCurrentTID);
//  120     OsTask_Suspend(OsCurrentTID);
        LDAB    OsCurrentTID
        JSR     OsTask_Suspend
//  121 
//  122 #if defined(OS_BCC2) || defined(OS_ECC2)
//  123     if (OsCurrentTCB->Activations>0) {  /* ???  */
//  124         OS_TASK_CLEAR_ALL_EVENTS(OsCurrentTID);
//  125         OSReadyTask(OsCurrentTID);
//  126         OSInitTask(OsCurrentTID,TRUE);
//  127     }
//  128 #endif
//  129 
//  130     OS_UNLOCK_INTERNAL_RESOURCE();
        JSR     OsRes_ReleaseInternalResource
//  131     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//  132 
//  133     OsExec_StartHighestReadyTask();
        JSR     OsExec_StartHighestReadyTask
//  134 
//  135     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  136     return E_OK; /* never reached */
        LDAB    #0x0
        RTS
//  137 }
//  138 
//  139 

        RSEG CODE:CODE:NOROOT(0)
//  140 StatusType ChainTask(TaskType TaskID)
ChainTask:
//  141 {
        PSHA
        STAB    0x0,SP
//  142 /*
//  143 **      Terminates running Task and activates another, enforces Rescheduling.
//  144 **
//  145 **       Standard-Status:
//  146 **              – No return to call level.
//  147 **              – E_OS_LIMIT – too many activations of <TaskID>.
//  148 **       Extended-Status:
//  149 **              – E_OS_ID – the task identifier is invalid.
//  150 **              – E_OS_RESOURCE – the calling task still occupies resources.
//  151 **              – E_OS_CALLEVEL – a call at the interrupt level.
//  152 */
//  153     SAVE_SERVICE_CONTEXT(OSServiceId_ChainTask,TaskID,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x6
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//  154 
//  155     ASSERT_VALID_TASKID(TaskID);
        TST     0x3,SP
        LEAS    0x3,SP
        BEQ     ??ChainTask_4
        LDAB    0x0,SP
        CMPB    #0x4
        BCS     ??ChainTask_5
??ChainTask_4:
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        JMP     .LWRD.(??ChainTask_6)
//  156     ASSERT_VALID_CALLEVEL(OS_CL_TASK);
??ChainTask_5:
        BRCLR   OsCallevel + 1,#0x1,??ChainTask_0
        BRA     ??ChainTask_7
??ChainTask_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        JMP     .LWRD.(??ChainTask_6)
//  157     ASSERT_INTERRUPTS_ENABLED_AT_TASK_LEVEL();
??ChainTask_7:
        TFR     CCR,B
        BITB    #0x10
        BEQ     ??ChainTask_8
        BRCLR   OsFlags,#0x2,??ChainTask_1
        BRA     ??ChainTask_8
??ChainTask_1:
        LDAB    #0x13
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x13
        JMP     .LWRD.(??ChainTask_6)
//  158     ASSERT_CURR_TASK_OCCUPIES_NO_RESOURCES();
??ChainTask_8:
        LDY     OsCurrentTCB
        TST     0x5,Y
        BNE     ??ChainTask_9
        BRCLR   OsFlags,#0x1,??ChainTask_2
??ChainTask_9:
        LDAB    #0x6
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x6
        BRA     ??ChainTask_6
//  159 
//  160     if (TaskID!=OsCurrentTID) {
??ChainTask_2:
        LDAB    0x0,SP
        CMPB    OsCurrentTID
        BEQ     ??ChainTask_10
//  161         WARN_IF_TO_MANY_ACTIVATIONS(TaskID);
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        TST     OS_TCB + 2,Y
        BEQ     ??ChainTask_10
        LDAB    #0x4
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x4
        BRA     ??ChainTask_6
//  162     }
//  163 
//  164     DISABLE_ALL_OS_INTERRUPTS();
??ChainTask_10:
        JSR     SuspendOSInterrupts
//  165     OS_UNLOCK_INTERNAL_RESOURCE();
        JSR     OsRes_ReleaseInternalResource
//  166     OS_TASK_DECR_ACTIVATIONS(OsCurrentTID);
//  167     OsTask_Suspend(OsCurrentTID);
        LDAB    OsCurrentTID
        JSR     OsTask_Suspend
//  168 
//  169     OS_TASK_INCR_ACTIVATIONS(TaskID);
//  170     OS_TASK_CLEAR_ALL_EVENTS(TaskID);
        LDAB    0x0,SP
        LDAA    #0x9
        MUL
        TFR     D,Y
        BRCLR   OS_TaskConf + 6,Y,#0x2,??ChainTask_3
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        CLR     OS_TCB + 3,Y
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        CLR     OS_TCB + 4,Y
//  171     OsTask_Ready(TaskID);
??ChainTask_3:
        LDAB    0x0,SP
        JSR     OsTask_Ready
//  172     OsTask_Init(TaskID,(TaskID==OsCurrentTID ? TRUE : FALSE));
        LDAB    0x0,SP
        CMPB    OsCurrentTID
        BNE     ??ChainTask_11
        LDAA    #0x1
        BRA     ??ChainTask_12
??ChainTask_11:
        LDAA    #0x0
??ChainTask_12:
        LDAB    0x0,SP
        JSR     OsTask_Init
//  173 
//  174     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//  175 
//  176     OsExec_StartHighestReadyTask();
        JSR     OsExec_StartHighestReadyTask
//  177 
//  178     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  179     return E_OK;
        LDAB    #0x0
??ChainTask_6:
        PULA
        RTS
//  180 }
//  181 
//  182 

        RSEG CODE:CODE:NOROOT(0)
//  183 StatusType GetTaskID(TaskRefType TaskID)
GetTaskID:
//  184 {
        PSHX
        TFR     Y,X
//  185 /*
//  186     "If no task currently running, the service returns INVALID_TASK
//  187     constant."
//  188     Hinweis zur Test-Prozedur: alle Tasks beenden, so dass nur noch
//  189     die IdleTask läuft und dann aus einer ISR 'GetTaskID' aufrufen!
//  190 
//  191 */
//  192     /* TaskID ist not known @ this point!!! */
//  193     SAVE_SERVICE_CONTEXT(OSServiceId_GetTaskID,/*TaskID*/NULL,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0xa
        PSHB
        LDD     #0x0
        LDY     #0x0
        JSR     OSSaveServiceContext
//  194     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2|OS_CL_ERROR_HOOK|
//  195         OS_CL_PRE_TASK_HOOK|OS_CL_POST_TASK_HOOK|OS_CL_PROTECTION_HOOK);
        LDD     #0x11f
        LEAS    0x3,SP
        BITB    OsCallevel + 1
        BNE     ??GetTaskID_0
        BITA    OsCallevel
        BNE     ??GetTaskID_0
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??GetTaskID_1
//  196 
//  197 /*    ASSERT_INTERRUPTS_ENABLED_AT_TASK_LEVEL(); */
//  198 
//  199     DISABLE_ALL_OS_INTERRUPTS();
??GetTaskID_0:
        JSR     SuspendOSInterrupts
//  200     *TaskID=OsCurrentTID;
        LDAB    OsCurrentTID
        STAB    0x0,X
//  201     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//  202 
//  203     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  204     return E_OK;
        LDAB    #0x0
??GetTaskID_1:
        PULX
        RTS
//  205 }
//  206 
//  207 

        RSEG CODE:CODE:NOROOT(0)
//  208 StatusType GetTaskState(TaskType TaskID,TaskStateRefType State)
GetTaskState:
//  209 {
        PSHX
        PSHA
        STAB    0x0,SP
        TFR     Y,X
//  210 /*
//  211 **      "Within a full-preemptive system, calling this operating system
//  212 **      service only provides a meaningful result if the task runs in an
//  213 **      interrupt disabling state at the time of calling. When a call is made
//  214 **      from a task in a full-preemptive system, the result may already be
//  215 **      incorrect at the time of evaluation."
//  216 */
//  217     /* State is mot known @ this point!!! */
//  218     SAVE_SERVICE_CONTEXT(OSServiceId_GetTaskState,TaskID,/*State*/NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0xc
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//  219 	ASSERT_VALID_TASKID(TaskID);
        TST     0x3,SP
        LEAS    0x3,SP
        BEQ     ??GetTaskState_0
        LDAB    0x0,SP
        CMPB    #0x4
        BCS     ??GetTaskState_1
??GetTaskState_0:
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??GetTaskState_2
//  220     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2|OS_CL_ERROR_HOOK|
//  221         OS_CL_PRE_TASK_HOOK|OS_CL_POST_TASK_HOOK|OS_CL_PROTECTION_HOOK);
??GetTaskState_1:
        LDD     #0x11f
        BITB    OsCallevel + 1
        BNE     ??GetTaskState_3
        BITA    OsCallevel
        BNE     ??GetTaskState_3
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??GetTaskState_2
//  222 
//  223     DISABLE_ALL_OS_INTERRUPTS();
??GetTaskState_3:
        JSR     SuspendOSInterrupts
//  224     *State=OS_TCB[TaskID].State;
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        TFR     D,Y
        LDAB    OS_TCB + 2,Y
        STAB    0x0,X
//  225     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//  226 /*
//  227 **      Standard-Status:
//  228 **              – E_OK – no error.
//  229 **      Extended-Status:
//  230 **               – E_OS_ID – the task identifier is invalid.
//  231 */
//  232 
//  233     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  234     return E_OK;
        LDAB    #0x0
??GetTaskState_2:
        PULA
        PULX
        RTS
//  235 }
//  236 
//  237 

        RSEG CODE:CODE:NOROOT(0)
//  238 StatusType Schedule(void)
Schedule:
//  239 {
//  240     SAVE_SERVICE_CONTEXT(OSServiceId_Schedule,NULL,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x8
        PSHB
        LDD     #0x0
        LDY     #0x0
        JSR     OSSaveServiceContext
//  241     ASSERT_VALID_CALLEVEL(OS_CL_TASK);
        LEAS    0x3,SP
        BRCLR   OsCallevel + 1,#0x1,??Schedule_0
        BRA     ??Schedule_4
??Schedule_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        RTS
//  242     ASSERT_CURR_TASK_OCCUPIES_NO_RESOURCES();
??Schedule_4:
        LDY     OsCurrentTCB
        TST     0x5,Y
        BNE     ??Schedule_5
        BRCLR   OsFlags,#0x1,??Schedule_1
??Schedule_5:
        LDAB    #0x6
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x6
        RTS
//  243     ASSERT_INTERRUPTS_ENABLED_AT_TASK_LEVEL();
??Schedule_1:
        TFR     CCR,B
        BITB    #0x10
        BEQ     ??Schedule_6
        BRCLR   OsFlags,#0x2,??Schedule_2
        BRA     ??Schedule_6
??Schedule_2:
        LDAB    #0x13
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x13
        RTS
//  244 /*    ASSERT_TASK_HAS_NO_SHARED_STACK();    */
//  245 
//  246 /*
//  247 **       Standard-Status:
//  248 **              – E_OK – no error.
//  249 **       Extended-Status:
//  250 **              – E_OS_CALLEVEL – a call at the interrupt level.
//  251 **              – E_OS_RESOURCE - calling task occupies resources.
//  252 */
//  253 
//  254     if (OS_TaskConf[OsCurrentTID].InternalResource!=INTERNAL_RES_NONE) {
??Schedule_6:
        LDAB    OsCurrentTID
        LDAA    #0x9
        MUL
        TFR     D,Y
        LDAB    OS_TaskConf + 8,Y
        INCB
        BEQ     ??Schedule_7
//  255 #if defined(OS_SCHED_POLICY_NON) ||  defined(OS_SCHED_POLICY_MIX)
//  256         OS_UNLOCK_INTERNAL_RESOURCE();
        JSR     OsRes_ReleaseInternalResource
//  257 #endif
//  258         OS_FORCE_SCHEDULE_FROM_TASK_LEVEL();
        BRCLR   OsFlags,#0x2,??Schedule_3
        BRA     ??Schedule_7
??Schedule_3:
        SWI
//  259     }
//  260 
//  261     CLEAR_SERVICE_CONTEXT();
??Schedule_7:
        CLR     Os_ServiceContext
//  262     return E_OK;
        LDAB    #0x0
        RTS
//  263 }
//  264 
//  265 

        RSEG CODE:CODE:NOROOT(0)
//  266 void OsTask_InitTasks(void)
OsTask_InitTasks:
//  267 {
        PSHA
//  268     uint8_least i;
//  269 
//  270     for (i=(uint8_least)1;i<OS_NUMBER_OF_TASKS;++i) {
        LDAB    #0x1
        STAB    0x0,SP
??OsTask_InitTasks_0:
        LDAB    0x0,SP
        CMPB    #0x3
        BCC     ??OsTask_InitTasks_1
//  271         if (Utl_BitGet((uint16)OS_TaskConf[i].Autostart,GetActiveApplicationMode())) {
        JSR     GetActiveApplicationMode
        PSHB
        LDAA    0x1,SP
        LDAB    #0x9
        MUL
        TFR     D,Y
        LDAB    OS_TaskConf + 7,Y
        EXG     B,Y
        PULB
        JSR     Utl_BitGet
        CMPB    #0x0
        BEQ     ??OsTask_InitTasks_2
//  272             OsTask_Init(i,FALSE);
        LDAA    #0x0
        LDAB    0x0,SP
        BSR     OsTask_Init
//  273             OsTask_Ready(i);
        LDAB    0x0,SP
        JSR     OsTask_Ready
//  274             OS_TASK_INCR_ACTIVATIONS(i);
//  275         }
//  276     }
??OsTask_InitTasks_2:
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
        BRA     ??OsTask_InitTasks_0
//  277 }
??OsTask_InitTasks_1:
        PULA
        RTS
//  278 
//  279 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  280 static void OsTask_Init(TaskType TaskID,boolean Schedule)
OsTask_Init:
//  281 {
        PSHX
        LEAS    -0x4,SP
        STAB    0x0,SP
        STAA    0x3,SP
//  282     OsTaskConfigurationType *task_def;
//  283     OsTCBType *tcb;
//  284 
//  285     if (TaskID>OS_NUMBER_OF_TASKS-(uint8)1) {
        LDAB    0x0,SP
        CMPB    #0x3
        BCC     ??OsTask_Init_0
//  286         return;
//  287     }
//  288 
//  289     task_def=(OsTaskConfigurationType*)&OS_TaskConf[TaskID];
        LDAB    0x0,SP
        LDAA    #0x9
        MUL
        ADDD    #OS_TaskConf
        STD     0x1,SP
//  290     tcb=&OS_TCB[TaskID];
        LDAB    0x0,SP
        LDAA    #0x7
        MUL
        ADDD    #OS_TCB
        TFR     D,X
//  291 
//  292 #if defined(OS_USE_STACKCHECKING)
//  293     OsUtilMemSet((void*)task_def->stack_addr,(uint8)OSSTACKFILLCHAR,(uint16)task_def->stack_size);
//  294 #endif
//  295 
//  296     tcb->Stackpointer=OsPortTaskStackInit(TaskID,&task_def->TaskFunction,
//  297         task_def->StackStart+task_def->StackSize-(uint8)1,Schedule);
        LDY     0x1,SP
        PSHY
        LDY     0x3,SP
        LDAB    0x4,Y
        CLRA
        PULY
        ADDD    0x2,Y
        ADDD    #0xffff
        PSHD
        LDAA    0x5,SP
        LDY     0x3,SP
        LDAB    0x2,SP
        JSR     OsPortTaskStackInit
        STY     0x0,X
//  298     tcb->State=SUSPENDED;
        CLR     0x2,X
//  299 #if defined(OS_BCC2) || defined(OS_ECC2)
//  300     tcb->Activations=(uint8)0x00;
//  301 #endif
//  302 
//  303 #if defined(OS_USE_RESOURCES)
//  304     tcb->CurrentPriority=task_def->Priority;
        LDY     0x3,SP
        LDAB    0x5,Y
        STAB    0x6,X
//  305     tcb->ResourceCount=(uint8)0x00;
        CLR     0x5,X
//  306 #endif
//  307 
//  308 #if defined(OS_ECC1) || defined(OS_ECC2)
//  309     tcb->EventsSet=(EventMaskType)0x00;
        CLR     0x3,X
//  310     tcb->EventsWaitingFor=(EventMaskType)0x00;
        CLR     0x4,X
//  311 #endif
//  312 }
        LEAS    0x2,SP
??OsTask_Init_0:
        LEAS    0x4,SP
        PULX
        RTS

        END
// 
// 1 046 bytes in segment CODE
// 
// 1 046 bytes of CODE memory
//
//Errors: none
//Warnings: 1
